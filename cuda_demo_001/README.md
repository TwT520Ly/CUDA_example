# cuda_demo_001

## 1 实现在GPU上进行加法运算

构建一个.cuh文件进行cuda_add函数的声明，在.cu文件中进行函数的定义。最后在.cpp文件中进行调用。

## 2 实现CUDA初始化过程

首先获取设备的cuda设备个数，如果没有支持cuda的设备，那么返回1。1是device0，是一个仿真设备。不支持cuda1.0以上的版本。因此可以使用prop.major进行判断，如果遍历完所有的设备依然没有大于cuda1.0的，那么就是没有支持的实际设备。使用cudaGetDevicePropertoes可以获取cuda的版本、设备的名称、内存的大小、最大的线程数、执行单元的频率等。如果cuda版本是7.5的, prop.major = 7, prop.minor = 5。

## 3 实现CUDA一个简单的核函数

实现一堆随机数的立方和相加的过程，需要首先在CPU上进行数据的初始化，然后在GPU（device）上创建内存区域（RAM），将数据拷贝到显存中。使用CUDA程序进行计算，然后将结果再传递回host端。使用cudaMalloc进行内存分配，然后使用cudaMemcpy进行内存拷贝，不过在进行拷贝的过程中，需要指定拷贝的方向。
对于在显卡执行的函数，不能有返回值，因此要通过指针的方式进行传递。

## 4 测试时间
CLOCKS_PER_SEC是系统一秒钟的时钟频率，clock_t是长整型类型。使用clock函数进行时间测试，但是需要除以CPU与GPU的时钟频率才可以得到大致的时间。在进行时间测试的时候，CPU使用clock测试是没有问题的，但是GPU使用clock出现了负值的情况。在kernel占用时间较小的时候，不会出现该问题，但是只要占用时间长一点，就会出错。将clock_t类型换成unsigned long long类型就没有问题了。怀疑是溢出的问题，在Linux系统下面出现了溢出时间数据范围的bug。

## 5 设备属性
使用cudaGetDeviceProperties可以获取到设备的一个属性集合。返回值cudaDeviceProp是一个结构体类型。属性clockRate单位是千兆赫兹。

## 6 并行计算

对于多个线程，需要调用多个核函数，因此需要在kernel中获取threadIdx进行标记。最后获取到线程数个结果，在CPU端进行累加。但是如果threads>1024，结果就会错误。
1.可以看到随着线程数的增加，并不会完全线性的提速，因此还需要更多的细节改进。

数组大小：1048576

|模式|时间(ms)|加速比|
|---|---|---|
|CPU|2.5|1|
|GPU|1250.25|1|
|GPU 64|26.29|47.55|
|GPU 128|12.88|97.07|
|GPU 512|3.350|373.20|
|GPU 1024|2.490|502.11|
|GPU 64(连续访存)|24.71|50.60|
|GPU 128(连续访存)|12.34|101.32|
|GPU 512(连续访存)|3.130|399.44|
|GPU 1024(连续访存)|1.750|714.43|
|GPU 32(b) 64(t)|0.834|1499.76|
|GPU 32(b) 128(t)|0.470|2662.01|
|GPU 32(b) 512(t)|0.190|6578.6|
|GPU 32(b) 1024(t)|0.290|4311.92|
|GPU 16(b) 64(t)|1.580|792.6|
|GPU 16(b) 512(t)|0.316|3956.49|
|GPU 64(b) 64(t)|0.457|2734.29|
|GPU 64(b) 128(t)|0.237|5284.06|

